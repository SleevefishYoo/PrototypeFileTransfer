import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.net.*;
import java.nio.ByteBuffer;

public class Receiver {
    private JPanel panel;
    private JTextField IPField;
    private JTextField ACKPortField;
    private JTextField directoryField;
    private JButton btnBrowse;
    private JTextField maxPacketSizeField;
    private JButton btnReady;
    private JLabel progressField;
    private JLabel statusLabel;
    private JTextField dataPortField;
    private JPanel receiver_gui;
    private JCheckBox unreliableMode;
    private JLabel descriptionLabel;
    private static String directory = "";
    private Thread curr_receiver;
    private InetAddress ip;
    private boolean debug = false;
    private final JFileChooser fc = new JFileChooser();

    private Receiver() {
        if (debug) debugSettings();
        btnBrowse.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                fc.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);
                fc.setDialogTitle("Choose Directory for saving transferred file");
                int returnVal = fc.showOpenDialog(btnBrowse);
                if (returnVal == JFileChooser.APPROVE_OPTION) {
                    directory = "" + fc.getSelectedFile();
                    directoryField.setText(directory);
                    System.out.println("Choosing: " + directory + " as the saving directory.");
                } else {
                    System.out.println("File choosing cancelled by user.");
                }
            }
        });
        btnReady.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {

                if (verify_input()) {
                    btnReady.setEnabled(false);
                    btnBrowse.setEnabled(false);
                    progressField.setText("0/0");
                    statusLabel.setText("Starting...");
                    if (unreliableMode.isSelected()) descriptionLabel.setText("Unreliable mode selected.");
                    else descriptionLabel.setText("No need to provide file name. File name is transferred from sender");
                    try {
                        curr_receiver = new Thread(new datagramReceiver());
                        curr_receiver.start();
                    } catch (IOException ex) {
                        ex.printStackTrace();
                    }
                }

            }
        });
    }

    public static void main(String[] args) {
        JFrame frame = new JFrame("Datagram Receiver");
        frame.setContentPane(new Receiver().receiver_gui);
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.pack();
        frame.setVisible(true);

    }

    private static boolean isPositiveNumeric(String str) {
        int i;
        try {
            i = Integer.parseInt(str);
        } catch (NumberFormatException n) {
            return false;
        }
        return i >= 0;
    }

    private boolean verify_input() {
        StringBuilder msgBuilder = new StringBuilder();
        try {
            ip = InetAddress.getByName(IPField.getText());
        } catch (UnknownHostException e) {
            msgBuilder.append("Host name or IP address not legal. Host not Found.\n");
        }
        if (!isPositiveNumeric(dataPortField.getText()) || Integer.parseInt(dataPortField.getText()) > 65535) {
            msgBuilder.append("Data Port not legal. 0-65535 is expected\n");
        }
        if (!isPositiveNumeric(ACKPortField.getText()) || Integer.parseInt(ACKPortField.getText()) > 65535) {
            msgBuilder.append("ACK Port not legal. 0-65535 is expected\n");
        }
        if (directory.equals("")) msgBuilder.append("No filePath chosen.");

        if (msgBuilder.toString().equals("")) return true;
        infoBox(msgBuilder.toString(), "Parameter(s) Invalid.");
        return false;
    }

    private static void infoBox(String infoMessage, String titleBar) {
        JOptionPane.showMessageDialog(null, infoMessage, titleBar, JOptionPane.INFORMATION_MESSAGE);
    }

    private void debugSettings() {
        IPField.setText("localhost");
        dataPortField.setText("9876");
        ACKPortField.setText("9877");
        directory = "testing/received";
    }

    {
// GUI initializer generated by IntelliJ IDEA GUI Designer
// >>> IMPORTANT!! <<<
// DO NOT EDIT OR ADD ANY CODE HERE!
        $$$setupUI$$$();
    }

    /**
     * Method generated by IntelliJ IDEA GUI Designer
     * >>> IMPORTANT!! <<<
     * DO NOT edit this method OR call it in your code!
     *
     * @noinspection ALL
     */
    private void $$$setupUI$$$() {
        receiver_gui = new JPanel();
        receiver_gui.setLayout(new GridBagLayout());
        panel = new JPanel();
        panel.setLayout(new GridBagLayout());
        panel.setAlignmentX(0.5f);
        panel.setAutoscrolls(true);
        panel.setInheritsPopupMenu(false);
        panel.setMinimumSize(new Dimension(720, 170));
        panel.setPreferredSize(new Dimension(720, 170));
        panel.putClientProperty("html.disable", Boolean.FALSE);
        GridBagConstraints gbc;
        gbc = new GridBagConstraints();
        gbc.gridx = 0;
        gbc.gridy = 0;
        receiver_gui.add(panel, gbc);
        panel.setBorder(BorderFactory.createTitledBorder(BorderFactory.createLineBorder(Color.black), null));
        final JLabel label1 = new JLabel();
        label1.setText("IP Addr.");
        gbc = new GridBagConstraints();
        gbc.gridx = 1;
        gbc.gridy = 1;
        gbc.anchor = GridBagConstraints.EAST;
        panel.add(label1, gbc);
        IPField = new JTextField();
        IPField.setColumns(2);
        IPField.setMinimumSize(new Dimension(64, 28));
        IPField.setPreferredSize(new Dimension(28, 29));
        gbc = new GridBagConstraints();
        gbc.gridx = 3;
        gbc.gridy = 1;
        gbc.gridwidth = 3;
        gbc.weightx = 0.5;
        gbc.anchor = GridBagConstraints.WEST;
        gbc.fill = GridBagConstraints.HORIZONTAL;
        panel.add(IPField, gbc);
        final JLabel label2 = new JLabel();
        label2.setText("Data Port:");
        gbc = new GridBagConstraints();
        gbc.gridx = 6;
        gbc.gridy = 1;
        gbc.anchor = GridBagConstraints.EAST;
        panel.add(label2, gbc);
        final JLabel label3 = new JLabel();
        label3.setText("ACK Port:");
        gbc = new GridBagConstraints();
        gbc.gridx = 10;
        gbc.gridy = 1;
        gbc.anchor = GridBagConstraints.EAST;
        panel.add(label3, gbc);
        ACKPortField = new JTextField();
        ACKPortField.setColumns(1);
        ACKPortField.setPreferredSize(new Dimension(17, 29));
        gbc = new GridBagConstraints();
        gbc.gridx = 12;
        gbc.gridy = 1;
        gbc.weightx = 1.0;
        gbc.anchor = GridBagConstraints.WEST;
        gbc.fill = GridBagConstraints.HORIZONTAL;
        panel.add(ACKPortField, gbc);
        final JLabel label4 = new JLabel();
        label4.setText("Save File To:");
        gbc = new GridBagConstraints();
        gbc.gridx = 1;
        gbc.gridy = 2;
        gbc.anchor = GridBagConstraints.WEST;
        panel.add(label4, gbc);
        directoryField = new JTextField();
        directoryField.setEditable(false);
        directoryField.setPreferredSize(new Dimension(64, 29));
        gbc = new GridBagConstraints();
        gbc.gridx = 3;
        gbc.gridy = 2;
        gbc.gridwidth = 4;
        gbc.weightx = 1.2;
        gbc.anchor = GridBagConstraints.WEST;
        gbc.fill = GridBagConstraints.HORIZONTAL;
        panel.add(directoryField, gbc);
        btnReady = new JButton();
        btnReady.setEnabled(true);
        btnReady.setText("Ready");
        gbc = new GridBagConstraints();
        gbc.gridx = 1;
        gbc.gridy = 3;
        gbc.gridwidth = 3;
        gbc.fill = GridBagConstraints.HORIZONTAL;
        panel.add(btnReady, gbc);
        final JLabel label5 = new JLabel();
        label5.setText("Transeferred:");
        gbc = new GridBagConstraints();
        gbc.gridx = 4;
        gbc.gridy = 3;
        gbc.weightx = 1.5;
        gbc.anchor = GridBagConstraints.EAST;
        panel.add(label5, gbc);
        progressField = new JLabel();
        progressField.setText("0/0");
        gbc = new GridBagConstraints();
        gbc.gridx = 5;
        gbc.gridy = 3;
        gbc.gridwidth = 2;
        gbc.weightx = 1.0;
        panel.add(progressField, gbc);
        dataPortField = new JTextField();
        dataPortField.setPreferredSize(new Dimension(64, 29));
        gbc = new GridBagConstraints();
        gbc.gridx = 8;
        gbc.gridy = 1;
        gbc.weightx = 1.0;
        gbc.weighty = 1.0;
        gbc.anchor = GridBagConstraints.WEST;
        gbc.fill = GridBagConstraints.HORIZONTAL;
        panel.add(dataPortField, gbc);
        final JPanel spacer1 = new JPanel();
        gbc = new GridBagConstraints();
        gbc.gridx = 13;
        gbc.gridy = 2;
        gbc.fill = GridBagConstraints.HORIZONTAL;
        panel.add(spacer1, gbc);
        final JPanel spacer2 = new JPanel();
        gbc = new GridBagConstraints();
        gbc.gridx = 0;
        gbc.gridy = 2;
        gbc.fill = GridBagConstraints.HORIZONTAL;
        panel.add(spacer2, gbc);
        final JPanel spacer3 = new JPanel();
        gbc = new GridBagConstraints();
        gbc.gridx = 9;
        gbc.gridy = 2;
        gbc.fill = GridBagConstraints.HORIZONTAL;
        panel.add(spacer3, gbc);
        final JPanel spacer4 = new JPanel();
        gbc = new GridBagConstraints();
        gbc.gridx = 2;
        gbc.gridy = 1;
        gbc.fill = GridBagConstraints.HORIZONTAL;
        panel.add(spacer4, gbc);
        final JPanel spacer5 = new JPanel();
        gbc = new GridBagConstraints();
        gbc.gridx = 7;
        gbc.gridy = 1;
        gbc.fill = GridBagConstraints.HORIZONTAL;
        panel.add(spacer5, gbc);
        final JPanel spacer6 = new JPanel();
        gbc = new GridBagConstraints();
        gbc.gridx = 5;
        gbc.gridy = 0;
        gbc.gridwidth = 2;
        gbc.fill = GridBagConstraints.VERTICAL;
        panel.add(spacer6, gbc);
        final JPanel spacer7 = new JPanel();
        gbc = new GridBagConstraints();
        gbc.gridx = 11;
        gbc.gridy = 1;
        gbc.fill = GridBagConstraints.HORIZONTAL;
        panel.add(spacer7, gbc);
        maxPacketSizeField = new JTextField();
        maxPacketSizeField.setEditable(false);
        maxPacketSizeField.setPreferredSize(new Dimension(64, 29));
        gbc = new GridBagConstraints();
        gbc.gridx = 12;
        gbc.gridy = 2;
        gbc.weightx = 1.0;
        gbc.weighty = 1.0;
        gbc.anchor = GridBagConstraints.WEST;
        gbc.fill = GridBagConstraints.HORIZONTAL;
        panel.add(maxPacketSizeField, gbc);
        final JLabel label6 = new JLabel();
        label6.setText("Max. Packet Size:");
        gbc = new GridBagConstraints();
        gbc.gridx = 10;
        gbc.gridy = 2;
        gbc.weightx = 1.0;
        gbc.anchor = GridBagConstraints.EAST;
        panel.add(label6, gbc);
        statusLabel = new JLabel();
        statusLabel.setText("Inactive");
        gbc = new GridBagConstraints();
        gbc.gridx = 10;
        gbc.gridy = 3;
        gbc.gridwidth = 3;
        panel.add(statusLabel, gbc);
        final JLabel label7 = new JLabel();
        label7.setText("Status:");
        gbc = new GridBagConstraints();
        gbc.gridx = 8;
        gbc.gridy = 3;
        gbc.anchor = GridBagConstraints.EAST;
        panel.add(label7, gbc);
        descriptionLabel = new JLabel();
        descriptionLabel.setText("No need to provide file name. File name is transferred from sender");
        gbc = new GridBagConstraints();
        gbc.gridx = 1;
        gbc.gridy = 5;
        gbc.gridwidth = 10;
        gbc.anchor = GridBagConstraints.WEST;
        panel.add(descriptionLabel, gbc);
        final JPanel spacer8 = new JPanel();
        gbc = new GridBagConstraints();
        gbc.gridx = 5;
        gbc.gridy = 6;
        gbc.gridwidth = 2;
        gbc.fill = GridBagConstraints.VERTICAL;
        panel.add(spacer8, gbc);
        btnBrowse = new JButton();
        btnBrowse.setText("Browse..");
        gbc = new GridBagConstraints();
        gbc.gridx = 8;
        gbc.gridy = 2;
        gbc.fill = GridBagConstraints.HORIZONTAL;
        panel.add(btnBrowse, gbc);
        final JPanel spacer9 = new JPanel();
        gbc = new GridBagConstraints();
        gbc.gridx = 5;
        gbc.gridy = 4;
        gbc.gridwidth = 2;
        gbc.fill = GridBagConstraints.VERTICAL;
        panel.add(spacer9, gbc);
        unreliableMode = new JCheckBox();
        unreliableMode.setText("Unreliable");
        gbc = new GridBagConstraints();
        gbc.gridx = 12;
        gbc.gridy = 5;
        gbc.anchor = GridBagConstraints.WEST;
        panel.add(unreliableMode, gbc);
    }

    /**
     * @noinspection ALL
     */
    public JComponent $$$getRootComponent$$$() {
        return receiver_gui;
    }

    class datagramReceiver implements Runnable {
        InetAddress ip;
        String filePath;
        int fileSize;
        DatagramPacket[] dataPackets;

        final byte[] HSBYTE = "##HS".getBytes();
        final byte[] DATABYTE = "DATA".getBytes();
        final byte[] ACKBYTE = "#ACK".getBytes();
        final byte[] EOFBYTE = "#EOF".getBytes();
        final int NUMLENGTH = 8;
        int dataPort, ACKPort, totalDataPacket, dataSize;

        datagramReceiver() throws IOException {
            ip = InetAddress.getByName(IPField.getText());
            filePath = Receiver.directory;
            dataSize = 127;
            dataPort = Integer.parseInt(dataPortField.getText());
            ACKPort = Integer.parseInt(ACKPortField.getText());
        }

        @Override
        public void run() {

            DatagramSocket dataSocket;
            byte[][] dataPackets;
            DatagramSocket ACKsocket;
            DatagramPacket[] HSpackets = new DatagramPacket[3];
            DatagramPacket received;
            int numReceived = 0;
            int numDropped = 0;


            try {
                dataSocket = new DatagramSocket(dataPort);
                dataSocket.setSoTimeout(0);
            } catch (IOException e) {
                infoBox("Failed to create/connect dataSocket on port: " + dataPort, "Send Failed");
                e.printStackTrace();
                statusLabel.setText("Error. Receiving failed.");
                setState(true);
                return;
            }
            try {
                ACKsocket = new DatagramSocket();
            } catch (IOException e) {
                infoBox("Failed to create/connect ACKsocket on port: " + ACKPort, "Send Failed");
                e.printStackTrace();
                statusLabel.setText("Error. Receiving failed.");
                setState(true);
                return;
            }
            statusLabel.setText("Waiting for handshake to complete...");
            int tempSize = 131;


            while (true) { //loop until HS is complete. Making sure all required params are received.
                byte[] buf = new byte[tempSize];
                received = new DatagramPacket(buf, tempSize);

                try {
                    dataSocket.receive(received);
                } catch (IOException e) {
                    e.printStackTrace();
                    infoBox("Unexpected dataSocket closure. Handshaking Failed", "Unexpected error.");
                    statusLabel.setText("Error. Receiving failed.");
                    ACKsocket.close();
                    setState(true);
                    return;
                }

                String[] parsedPacket = parsePacket(received);
                if (parsedPacket[0].equals("##HS") && HSpackets[Integer.parseInt(parsedPacket[1])] == null) {
                    HSpackets[Integer.parseInt(parsePacket(received)[1])] = received;
                    numReceived++;
                    updateProgressField(numReceived, totalDataPacket);
                }
                System.out.println("Received " + parsedPacket[0] + " packet #" + parsedPacket[1]);
                if (parsedPacket[0].equals("DATA")) {
//                    System.out.println("Data: " + parsedPacket[2]);
//                    System.out.println("Data length: " + received.getData().length);
                }
                if (parsedPacket[0].equals("##HS")) {
                    if (Integer.parseInt(parsedPacket[1]) == 0) {
                        System.out.println("Received packetSize: " + parsedPacket[2]);
                        dataSize = Integer.parseInt(parsedPacket[2]);
                    } else if (Integer.parseInt(parsedPacket[1]) == 2) {
                        System.out.println("Received fileSize: " + parsedPacket[2]);
                        fileSize = Integer.parseInt(parsedPacket[2]);
                        tempSize = dataSize + 12;
                    } else {
                        System.out.println("Received File name: " + parsedPacket[2]);
                        filePath += "/" + parsedPacket[2];
                    }
                    try {
                        System.out.println("Sending ACK for " + parsedPacket[0] + " packet #" + parsedPacket[1]);
                        ACKsocket.send(prepareHS(Integer.parseInt(parsePacket(received)[1])));
                    } catch (IOException e) {
                        e.printStackTrace();
                        infoBox("Unexpected ACKsocket closure. Handshaking Failed", "Unexpected error.");
                        statusLabel.setText("Error. Receiving failed.");
                        dataSocket.close();
                        setState(true);
                        return;
                    }
                } else break;
            }

            dataSize = Integer.parseInt(parsePacket(HSpackets[0])[2]);
            maxPacketSizeField.setText("" + (dataSize));
            fileSize = Integer.parseInt(parsePacket(HSpackets[2])[2]);
            totalDataPacket = fileSize / dataSize + 1;
            dataPackets = new byte[fileSize / dataSize + ((fileSize % dataSize != 0) ? 1 : 0)][];
            updateProgressField(numReceived, totalDataPacket);


            dataPackets[Integer.parseInt(parsePacket(received)[1]) / dataSize] = copyOfRange(received.getData(), 12,
                    received.getLength());
//            System.out.println("Adding DATA #" + parsePacket(received)[1] + "'s data to the data Packet...");

            statusLabel.setText("Receiving...");

            try {
                ACKsocket.send(prepareACK(Integer.parseInt(parsePacket(received)[1])));
            } catch (IOException e) {
                e.printStackTrace();
                infoBox("Unexpected ACKSocket closure. HS sending Failed", "Unexpected error.");
                statusLabel.setText("Error. Receiving failed.");
                dataSocket.close();
                setState(true);
                return;
            }
            while (true) {
                received = new DatagramPacket(new byte[dataSize + 12], dataSize + 12);

                try {
                    dataSocket.receive(received);
                } catch (IOException e) {
                    e.printStackTrace();
                    infoBox("Unexpected socket(s) closure. Data receiving Failed", "Unexpected error.");
                    statusLabel.setText("Error. Receiving failed.");
                    ACKsocket.close();
                    setState(true);
                    return;
                }

                String[] parsedPacket = parsePacket(received);
                if (unreliableMode.isSelected() && numReceived % 10 == 0 && !parsedPacket[0].equals("#EOF")) {
                    totalDataPacket++;
                    numReceived++;
                    numDropped++;
                    descriptionLabel.setText("Unreliable mode selected. Total dropped package: " + numDropped);
                    continue;
                }
                System.out.println("Received " + parsedPacket[0] + " packet #" + parsedPacket[1]);


                if (parsedPacket[0].equals("##HS")) {
                    if (Integer.parseInt(parsedPacket[1]) == 0 || Integer.parseInt(parsedPacket[1]) == 2) {
                        System.out.println("Received packetSize/fileSize: " + parsedPacket[2]);
                    } else {
                        System.out.println("Received File name: " + parsedPacket[2]);
                    }
                } else if (parsedPacket[0].equals("DATA")) {
//                    System.out.println("Data: " + parsedPacket[2]);
//                    System.out.println("Data length: " + received.getData().length);
                }

                if (parsePacket(received)[0].equals("#EOF")) {
                    try {
                        ACKsocket.send(prepareEOF());
                        break;
                    } catch (IOException e) {
                        e.printStackTrace();
                        infoBox("Unexpected ACKSocket closure. EOF sending Failed", "Unexpected error.");
                        dataSocket.close();
                        statusLabel.setText("Error. Receiving failed.");
                        setState(true);
                        return;
                    }
                }

                if (parsePacket(received)[0].equals("##HS")) {
                    try {
                        ACKsocket.send(prepareHS(2));
                        continue;
                    } catch (IOException e) {
                        e.printStackTrace();
                        infoBox("Unexpected ACKSocket closure. HS sending Failed", "Unexpected error.");
                        statusLabel.setText("Error. Receiving failed.");
                        dataSocket.close();
                        setState(true);
                        return;
                    }
                }
                if (parsedPacket[0].equals("DATA") && dataPackets[Integer.parseInt(parsedPacket[1]) / dataSize] == null) {
//                    System.out.println("Adding DATA #" + parsedPacket[1] + "'s data to the data Packet...");
                    dataPackets[Integer.parseInt(parsedPacket[1]) / dataSize] = copyOfRange(received.getData(), 12,
                            received.getLength());
                    numReceived++;
                    updateProgressField(numReceived, totalDataPacket);
                }

                try {
                    ACKsocket.send(prepareACK(Integer.parseInt(parsePacket(received)[1])));
                } catch (IOException e) {
                    e.printStackTrace();
                    infoBox("Unexpected ACKSocket closure. HS sending Failed", "Unexpected error.");
                    statusLabel.setText("Error. Receiving failed.");
                    setState(true);
                    return;
                }

            }

            statusLabel.setText("Writing to file...");
            File file = new File(filePath);
            FileOutputStream fos = null;
            if (!file.exists()) {
                try {
                    file.createNewFile();
                } catch (IOException e) {
                    e.printStackTrace();
                    statusLabel.setText("Error. Receiving failed.");
                    infoBox("Failed to create/write to file " + filePath + ". Terminating.", "File failed to create");
                    setState(true);
                    return;
                }
            }
            try {
                fos = new FileOutputStream(file);
                fos.write(createFileByteArray(dataPackets));
                fos.close();

            } catch (IOException e) {
                e.printStackTrace();
            }


            dataSocket.close();
            ACKsocket.close();
            btnReady.setEnabled(true);
            btnBrowse.setEnabled(true);
            setState(true);
            statusLabel.setText("File received. Location:" + filePath);
        }

        private byte[] createFileByteArray(byte[][] dataPackets) {
            ByteBuffer fileBytes = ByteBuffer.allocate(fileSize);
            for (byte[] packetData : dataPackets) {
                fileBytes.put(packetData);
            }
            return fileBytes.array();
        }

        private void updateProgressField(int received, int totalDataPacket) {
            progressField.setText(received + "/" + (totalDataPacket + 2));

        }

        DatagramPacket prepareHS(int mode) {
            int pointer = 0;
            byte[] packetData = new byte[127];
            if (mode == 0) {
                System.arraycopy(HSBYTE, 0, packetData, pointer, HSBYTE.length);
                pointer += HSBYTE.length;
                System.arraycopy(intToByteArr(0), 0, packetData, pointer, NUMLENGTH);
            } else if (mode == 1) {
                System.arraycopy(HSBYTE, 0, packetData, pointer, HSBYTE.length);
                pointer += HSBYTE.length;
                System.arraycopy(intToByteArr(1), 0, packetData, pointer, NUMLENGTH);
            } else if (mode == 2) {
                System.arraycopy(HSBYTE, 0, packetData, pointer, HSBYTE.length);
                pointer += HSBYTE.length;
                System.arraycopy(intToByteArr(2), 0, packetData, pointer, NUMLENGTH);
            } else {
                throw new IllegalArgumentException("Only mode 0 and 1 is allowed.");
            }
            return new DatagramPacket(packetData, packetData.length, ip, ACKPort);
        }

        DatagramPacket prepareACK(int seqNum) {
            int pointer = 0;
            byte[] packetData = new byte[dataSize];
            System.arraycopy(ACKBYTE, 0, packetData, pointer, HSBYTE.length);
            pointer += ACKBYTE.length;
            System.arraycopy(intToByteArr(seqNum), 0, packetData, pointer, NUMLENGTH);
            return new DatagramPacket(packetData, packetData.length, ip, ACKPort);
        }

        DatagramPacket prepareEOF() {
            int pointer = 0;
            byte[] packetData = new byte[dataSize];
            System.arraycopy(EOFBYTE, 0, packetData, pointer, HSBYTE.length);
            pointer += EOFBYTE.length;
            System.arraycopy(intToByteArr(0), 0, packetData, pointer, NUMLENGTH);
            return new DatagramPacket(packetData, packetData.length, ip, ACKPort);
        }

        byte[] intToByteArr(int i) {
            return ByteBuffer.allocate(NUMLENGTH).putInt(i).array();
        }

        byte[] copyOfRange(byte[] srcArr, int start, int end) {
            int length = (end > srcArr.length) ? srcArr.length - start : end - start;
            byte[] destArr = new byte[length];
            System.arraycopy(srcArr, start, destArr, 0, length);
            return destArr;
        }

        void setState(boolean state) {
            btnReady.setEnabled(state);
            btnBrowse.setEnabled(state);
            statusLabel.setText((state) ? "Inactive" : "Busy...");
        }


        String[] parsePacket(DatagramPacket packet) {
            String[] parsedPacket = new String[3];
            parsedPacket[0] = new String(copyOfRange(packet.getData(), 0, 4));
            parsedPacket[1] = "" + ByteBuffer.wrap(packet.getData(), 4, 8).getInt();
            parsedPacket[2] = new String(copyOfRange(packet.getData(), 12, packet.getData().length));
            if (parsedPacket[0].equals("##HS")) {
                if (Integer.parseInt(parsedPacket[1]) == 0 || Integer.parseInt(parsedPacket[1]) == 2) {
                    parsedPacket[2] = "" + ByteBuffer.wrap(packet.getData(), 12, 8).getInt();
                } else {
                    String temp = parsedPacket[2];
                    parsedPacket[2] = temp.split("\n")[0];
                }
            }
            return parsedPacket;
        }
    }
}

